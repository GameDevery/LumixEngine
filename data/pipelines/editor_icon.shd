include "pipelines/common.glsl"

texture_slot {
	name = "Albedo",
	default_texture = "textures/common/white.tga"
}

common [[
	struct VSOutput {
		float2 uv : TEXCOORD0;
		float3 wpos : TEXCOORD1;
		float3 normal : TEXCOORD2;
		float4 position : SV_POSITION;
	};
]]

vertex_shader [[
	#define ATTR(X) TEXCOORD##X
	cbuffer Model : register(b4) {
		float4x4 u_model;
	};
	struct Input {
		float3 position : TEXCOORD0;
		#ifdef UV0_ATTR
			float2 uv : ATTR(UV0_ATTR);
		#endif
		float3 normal : ATTR(NORMAL_ATTR);
	};

	VSOutput main(Input input) {
		VSOutput output;
		#ifdef UV0_ATTR
			output.uv = input.uv;
		#else
			output.uv = 0;
		#endif
		float4 p = mul(float4(input.position, 1), mul(u_model, Global_view));
		output.wpos = p.xyz;
		output.normal = input.normal;
		output.position = mul(p, Global_projection_no_jitter);
		return output;
	}
]]

fragment_shader [[
	cbuffer Drawcall2 : register(b5) {
		uint u_gbuffer_depth;
	};
	
	float4 main(VSOutput input) : SV_TARGET {
		float2 screen_uv = input.position.xy / Global_framebuffer_size;
		float3 wpos = getViewPosition(u_gbuffer_depth, Global_inv_view_projection, screen_uv);
		float4 albedo = sampleBindless(LinearSampler, t_albedo, input.uv);
		#ifdef ALPHA_CUTOUT
			if (albedo.a < 0.5) discard;
		#endif
		float d = dot(Global_light_dir.xyz, input.normal);
		float4 o_color;
		o_color.rgb = albedo.rgb * saturate(max(0, -d) + 0.25 * max(0, d) + 0.25);
		o_color.a = 1;
		if(length(wpos) < length(input.wpos)) o_color.rgb *= 0.25;
		return o_color;
	}
]]